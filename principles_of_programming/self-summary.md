# 第一章：前提
## プログラミングに銀の弾丸はない

どの場合にも、どのソフトウェアにもある諸問題を鎮める一つの解決策が存在しません。
ソフトウェアその物は本質的に困難性を持っています。その理由：

* **複雑性:** ソフトウェアは大きい
*  **同調性:**　ソフトウェアは実世界の状況を表すため、その実世界の状況に影響される
* **可変性:**　ユーザーの要求が変えるため、ソフトウェアも変えなければならない
* **不可視性:** ソフトウェアは概念的な成果物なので、そのものが見えなく、抽象的な可視化しかできない

## コードは設計書である

コードは製造ではなく、設計書です。 製造は設計後改善せきません。ですが、コードはよく改善されます。コードは設計書なので改善できます。よって、プログラマは設計者である、設計者はプログラマである。コードとして良い設計と立てるべきです。

**Rosetta stone:** ドキュメントとしてコードしか他が価値がないというわけではありません。コードはwhat と howを表現しますが、whyと表現します。ロゼッタストーンのような他のドキュメントは開発環境について説明して、将来の保守者に役に立ちます。

## コードは必ず変更される

ソフトウェアは以下の理由で変更されなくてはなりません：修正、要求の追加、リファクタリング。変更に強いコードは読みやすいコードです。そのため、コードを書くのに時間をかけて、読む時間を短縮します。

# 第二章：原則
## KISS: Keep It Simple, Stupid

いつも簡単なコードを目指します。簡単なコードの拡張性、保守性が高いです。コードはコミュニケーションの場なのでそれもシンプルさのおかげで上がります。
コードが余計に複雑なるの例の理由：
* 自分のプログラマとしての能力を発揮したかって巧妙すぎるコードを書く
* 将来に備えたいため余計な拡張性を提供して、複雑化してしまって実際拡張性が低くなる
* ユーザーの意見を聞かないで勝手に自分の意見によって必要がない機能を追加する

適用範囲：インターフェースなどのほかの部分も利用性を高くするためシンプルにおくべきです

## DRY: Don't Repeat Yourseld

コードの重複を避けます。コードのコピーペーストはいけません。なぜなら、重複したコードは：
* 長くなって読む作業は大変
* 修正しにくい：コピーペーストしたコードは盲目に同じ変更できない。周りのコードの様子によって変更する必要がある。よって変更はもっと時間がかかる。
* レガシーコード：重複したコードはテストがないレガシーコードであるのでその重複した様子に落ち込んだ

重複を避けるため共通の部分を引き出して抽象化して関数やモジュールの形にします。

適用範囲：DRYはどの繰り返す作業もに適用します。例えばテストにおけると手作業しないで自動化すべきです。自動化によって同じ仕事の手作業の繰り返しを避けられます。

Data Impedence: データの抽象型が異なる場合重複しなきゃなりません。例えばオブジェクト指向プログラムとデータベースのデータのつなぐ際抽象型が違うので同じデータの表現を何度も書かなければなりません。でもこのような重複が自動的に行えます。

OFOP (One Fact In One Place): データベースにおける重複を避けるということです。正規化だけによって行えます。

OAOO (Once And Only Once): DRYと同じ意味しますがプログラミングだけにおけます。

レガシーコードは適当なテストがないコードと意味します。

## YAGNI: You Aren't Going to Need It

現時点で必要がある最低限のコードを書きます。将来の観点で拡張性を提供をしたっかても将来のニーズは予測できません。なので余計な拡張性を実装すれば設計が複雑なる、逆に拡張性が低くなります。単純のコードは最も拡張しやすいです。なので今必要の機能やコードをさけ、シンプルさを保ちます。

適用範囲：コードと同じように、機能も余計なものを提供しません。インターフェースは複雑になって利用性が下がります。

Do The Simplest Thing That Could Possibly Work: この原則を従うと今の問題点だけに集中できます。今求められる機能だけの実装に集中します。

## PIE: Program Intently and Expressively

コードはチームメンバーの間のコミュニケーションのドキュメントです。コードだけがどのドキュメントよりもソフトウェアの動きの完全に説明します。なのでソフトウェアを変更や修正したい人はコードを読んで理解しなきゃいけません。よって自分が書いたコードは他人に読まれるという意識を持ちながらコードを書きます。自分が書いたことより何倍よりも他の人に読まれます。よって意図を伝えて読みやすい理解しやすいコードを書くべきです。それは保守と修正のコストを減少します。

モグラたたき：コードの様子が悪いと時折問題が発生します。その際だめな設計したコードを書き直すべきですがそうしないで今の問題だけをpatchするといつかまた問題が発生します。

コメントでWhy：コードはwhat and howと伝えますがWhyは伝えません。コメントで動機を書いておきます。

## SLAP: Single Level of Abstraction Principle

コードを抽象化して、抽象化レベルによってコードを揃います。関数の抽象レベルは高水準から
低水準の順に進みます。本物の具体的な命令は高水準の関数に行われます。高水準は一つ下のレベルの関数を呼び出します。抽象レベルを混ぜてはいけません。下のレベルの処理は隠蔽されて、高水準と中水準の関数名は目次のように見えます。
これ複合関数を定義します。

適用範囲：関数のようにモジュールでも継承を使って階層的な抽象化できます。

SLAPの手順：まず具体的な処理を書いてからそれを抽象レベルによって整理します。

## OCP: Open Close Principle

Open：拡張に対して開いている
Close：拡張の影響の範囲は狭く、他の部分に対しての影響はできるだけ限られている

コードはいつも変化されるため変更に対して柔軟性を持つ必要があります。この原則によって新機能の追加と変更は容易なりますが変更の影響はそのモジュール内に限ります。
これを実現ためインターフェースは使えます。インタフェースはクライアントとサーバーの間の連絡の仲介になります。これで、サーバーに変更があればクライアントのコードも変更する必要がなくなります。

適用範囲：柔軟性をもたらすようにすればコードが複雑なるので確実に変更されるところがけにこの原則を活かします。一方、他の部分は変更が入った際OCPを適用か検討します。

## 名前重要

名前の重要さ：
* 名前を付ける行為：相応しい名前を付けるのに設計、各要素の役割などについて正しく理解する必要がある
* 名前そのもの：コミュニケーションに必須であり、コードの理解に役に立つ

名前はコードのUIです：
* 名前だけでコードは何をしているか把握でき、中身を読む必要がなくなります。
* コードの使い方は名前にみちびかされます。

名前を付ける際注意点。名前は：
* 短いコメントみたい
* 誤解されない確認する
* 手段を記述しない。目的や効果だけを記述する。
* 前にテストコードを書くことが名づけることに役に立つ
* 発音可能
* 検索が容易

メンタルマッピング：名前は不適だと読み手はコードを理解のに中身まで読んで理解して自分で意味がある適切な名前を頭の中につける必要になります。名前は元々適切であればその労働を回避できます。

Loopback check: ループ考え方で名づける：処理の説明から名前を考え、名前からまた説明を考えます。説明が矛盾なく統一したら適切な名前だと思えます。
