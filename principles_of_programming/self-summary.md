# 第一章：前提
## プログラミングに銀の弾丸はない

どの場合にも、どのソフトウェアにもある諸問題を鎮める一つの解決策が存在しません。
ソフトウェアその物は本質的に困難性を持っています。その理由：

* **複雑性:** ソフトウェアは大きい
*  **同調性:**　ソフトウェアは実世界の状況を表すため、その実世界の状況に影響される
* **可変性:**　ユーザーの要求が変えるため、ソフトウェアも変えなければならない
* **不可視性:** ソフトウェアは概念的な成果物なので、そのものが見えなく、抽象的な可視化しかできない

## コードは設計書である

コードは製造ではなく、設計書です。 製造は設計後改善せきません。ですが、コードはよく改善されます。コードは設計書なので改善できます。よって、プログラマは設計者である、設計者はプログラマである。コードとして良い設計と立てるべきです。

**Rosetta stone:** ドキュメントとしてコードしか他が価値がないというわけではありません。コードはwhat と howを表現しますが、whyと表現します。ロゼッタストーンのような他のドキュメントは開発環境について説明して、将来の保守者に役に立ちます。

## コードは必ず変更される

ソフトウェアは以下の理由で変更されなくてはなりません：修正、要求の追加、リファクタリング。変更に強いコードは読みやすいコードです。そのため、コードを書くのに時間をかけて、読む時間を短縮します。

# 第二章：原則
## KISS: Keep It Simple, Stupid

いつも簡単なコードを目指します。簡単なコードの拡張性、保守性が高いです。コードはコミュニケーションの場なのでそれもシンプルさのおかげで上がります。
コードが余計に複雑なるの例の理由：
* 自分のプログラマとしての能力を発揮したかって巧妙すぎるコードを書く
* 将来に備えたいため余計な拡張性を提供して、複雑化してしまって実際拡張性が低くなる
* ユーザーの意見を聞かないで勝手に自分の意見によって必要がない機能を追加する

適用範囲：インターフェースなどのほかの部分も利用性を高くするためシンプルにおくべきです

## DRY: Don't Repeat Yourseld

コードの重複を避けます。コードのコピーペーストはいけません。なぜなら、重複したコードは：
* 長くなって読む作業は大変
* 修正しにくい：コピーペーストしたコードは盲目に同じ変更できない。周りのコードの様子によって変更する必要がある。よって変更はもっと時間がかかる。
* レガシーコード：重複したコードはテストがないレガシーコードであるのでその重複した様子に落ち込んだ

重複を避けるため共通の部分を引き出して抽象化して関数やモジュールの形にします。

適用範囲：DRYはどの繰り返す作業もに適用します。例えばテストにおけると手作業しないで自動化すべきです。自動化によって同じ仕事の手作業の繰り返しを避けられます。

Data Impedence: データの抽象型が異なる場合重複しなきゃなりません。例えばオブジェクト指向プログラムとデータベースのデータのつなぐ際抽象型が違うので同じデータの表現を何度も書かなければなりません。でもこのような重複が自動的に行えます。

OFOP (One Fact In One Place): データベースにおける重複を避けるということです。正規化だけによって行えます。

OAOO (Once And Only Once): DRYと同じ意味しますがプログラミングだけにおけます。

レガシーコードは適当なテストがないコードと意味します。

## YAGNI: You Aren't Going to Need It

現時点で必要がある最低限のコードを書きます。将来の観点で拡張性を提供をしたっかても将来のニーズは予測できません。なので余計な拡張性を実装すれば設計が複雑なる、逆に拡張性が低くなります。単純のコードは最も拡張しやすいです。なので今必要の機能やコードをさけ、シンプルさを保ちます。

適用範囲：コードと同じように、機能も余計なものを提供しません。インターフェースは複雑になって利用性が下がります。

Do The Simplest Thing That Could Possibly Work: この原則を従うと今の問題点だけに集中できます。今求められる機能だけの実装に集中します。

## PIE: Program Intently and Expressively

コードはチームメンバーの間のコミュニケーションのドキュメントです。コードだけがどのドキュメントよりもソフトウェアの動きの完全に説明します。なのでソフトウェアを変更や修正したい人はコードを読んで理解しなきゃいけません。よって自分が書いたコードは他人に読まれるという意識を持ちながらコードを書きます。自分が書いたことより何倍よりも他の人に読まれます。よって意図を伝えて読みやすい理解しやすいコードを書くべきです。それは保守と修正のコストを減少します。

モグラたたき：コードの様子が悪いと時折問題が発生します。その際だめな設計したコードを書き直すべきですがそうしないで今の問題だけをpatchするといつかまた問題が発生します。

コメントでWhy：コードはwhat and howと伝えますがWhyは伝えません。コメントで動機を書いておきます。

## SLAP: Single Level of Abstraction Principle

コードを抽象化して、抽象化レベルによってコードを揃います。関数の抽象レベルは高水準から
低水準の順に進みます。本物の具体的な命令は高水準の関数に行われます。高水準は一つ下のレベルの関数を呼び出します。抽象レベルを混ぜてはいけません。下のレベルの処理は隠蔽されて、高水準と中水準の関数名は目次のように見えます。
これ複合関数を定義します。

適用範囲：関数のようにモジュールでも継承を使って階層的な抽象化できます。

SLAPの手順：まず具体的な処理を書いてからそれを抽象レベルによって整理します。

## OCP: Open Close Principle

Open：拡張に対して開いている
Close：拡張の影響の範囲は狭く、他の部分に対しての影響はできるだけ限られている

コードはいつも変化されるため変更に対して柔軟性を持つ必要があります。この原則によって新機能の追加と変更は容易なりますが変更の影響はそのモジュール内に限ります。
これを実現ためインターフェースは使えます。インタフェースはクライアントとサーバーの間の連絡の仲介になります。これで、サーバーに変更があればクライアントのコードも変更する必要がなくなります。

適用範囲：柔軟性をもたらすようにすればコードが複雑なるので確実に変更されるところがけにこの原則を活かします。一方、他の部分は変更が入った際OCPを適用か検討します。

## 名前重要

名前の重要さ：
* 名前を付ける行為：相応しい名前を付けるのに設計、各要素の役割などについて正しく理解する必要がある
* 名前そのもの：コミュニケーションに必須であり、コードの理解に役に立つ

名前はコードのUIです：
* 名前だけでコードは何をしているか把握でき、中身を読む必要がなくなります。
* コードの使い方は名前にみちびかされます。

名前を付ける際注意点。名前は：
* 短いコメントみたい
* 誤解されない確認する
* 手段を記述しない。目的や効果だけを記述する。
* 前にテストコードを書くことが名づけることに役に立つ
* 発音可能
* 検索が容易

メンタルマッピング：名前は不適だと読み手はコードを理解のに中身まで読んで理解して自分で意味がある適切な名前を頭の中につける必要になります。名前は元々適切であればその労働を回避できます。

Loopback check: ループ考え方で名づける：処理の説明から名前を考え、名前からまた説明を考えます。説明が矛盾なく統一したら適切な名前だと思えます。

# プログラミングセオリーを支える三つの価値

## コミュニケーション

コードはコミュニケーションのためのドキュメントだとみなします。コードが正しく実行しているというのに加えて読みやすいべきです。コードから生じるほとんどのコストは保守に関します。よってコードは何を伝ていると考えながら読み手の視点からコードを書きいます。

## シンプル

余計な複雑さを排除してコードをいつもシンプルにします。コードがある分、修正と保守と拡張が難しくなります。よってコードの量をできるだけ減らして必要な要素だけを実装します。必要な部分を不要な部分から見分けます。

## 柔軟性

コードは変更しかねませんので変更しやすいように設計して柔軟性をもたらします。変更理由は修正、拡張、機能追加、条件に変化などとなります。柔軟性をもたらすため変更を予測しようとして余計に複雑な設計しないで、シンプルな変更しやすい設計にします。

# プログラミングセオリーを実現する六つの原則

## 結果の局所化

変更の範囲を抑えるべきです。ある部分の変更が全く違う部分に影響を及ぼさないべきです。これによってでバッギングが容易になります。コードの変更はどこに影響しているか楽に把握できます。原則を満たすため関係の高い要素を近く置くべきです。

# プログラミングセオリーを支える三つの価値

## コミュニケーション

コードはコミュニケーションのためのドキュメントだとみなします。コードが正しく実行しているというのに加えて読みやすいべきです。コードから生じるほとんどのコストは保守に関します。よってコードは何を伝ていると考えながら読み手の視点からコードを書きいます。

## シンプル

余計な複雑さを排除してコードをいつもシンプルにします。コードがある分、修正と保守と拡張が難しくなります。よってコードの量をできるだけ減らして必要な要素だけを実装します。必要な部分を不要な部分から見分けます。

## 柔軟性

コードは変更しかねませんので変更しやすいように設計して柔軟性をもたらします。変更理由は修正、拡張、機能追加、条件に変化などとなります。柔軟性をもたらすため変更を予測しようとして余計に複雑な設計しないで、シンプルな変更しやすい設計にします。

# プログラミングセオリーを実現する六つの原則

## 結果の局所化

変更の範囲を抑えるべきです。ある部分の変更が全く違う部分に影響を及ぼさないべきです。これによってでバッギングが容易になります。コードの変更はどこに影響しているか楽に把握できます。原則を満たすため関係の高い要素を近く置くべきです。

## 繰り返しの最小限

コードの重複を削除します。共通なコードを関数化します。重複したコードの修正と保守が難しいです。原則は果たすため小さなコードのブロックを書きます。それでどの場所がどのぐらい共通か明確に把握できます。

## ロジックとデータの一体化

データとそのデータを処理するロジックを近くに配置します。なぜなら両方が高い関係性を持って、変更されるタイミングが同じです。最初のうちはデータとロジックはどのぐらい関係するか完璧に把握できないのでコードを書いて試行錯誤してその関係性が明確になります。

## 対称性

同じことを同じように表現します。するとコードが読みやすくなり、すべてのコードを読まなくてもどの機能があるか推測できます。例えば追加メソッドがあれば削除メソッドもあるべき、関数内の関数呼出の抽象レベルを合わせます、同じような引数を受けます。

## 宣言型プログラミング

命令型プログラミングは問題の解法を記述します。そんなコードを読むのにはプログラムのフローと状態を意識する必要があります。一方宣言型プログラミングは問題の定義します。どんな結果が欲しいか記述します。

## 変更頻度

同じタイミングで変更される要素を局所化します。同じタイミングで変更される要素が同じ理由で変更されます。よってモジュールの各要素が同じ理由だけで変更されるようにします。しないとある部分の変更がその変更と関係のない部分まで影響を及ぼします。

**SRP: Single Responsibility Principle:** モジュールが唯一な責任を持つべきです。それで変更される理由も一つになりますので保守しやすくなります。変更理由は多いと頻繁に変更され、関係のない変更を影響で脆くなります。

# アーキテクチャ根底方法

## 抽象

抽象を使って概念の間に線引きして、コードをわかりやすいように分割します。捨象で必要な特徴だけに集中します。一般化で複数の概念の共通のパターンを認識します。

## カプセル化

データとそのデータを処理するロジックを近くにおきます。関係が深い要素をまとめれば問題を分割でき、修正と保守がしやすくなります。

## 情報隠蔽

モジュールのインタフェースと使い方をシンプルにするため機能を提供しながらできる限り外部に見せる関数とデータを最小限します。これで内部の変更が外部に及ぼす影響を最小限できます。

**パルナスの原則：**
* モジュールを使用するためだけの情報を外部に見せる
* モジュールを作成する際、機能を果たせるだけの情報を提供する

## パッケージ化

モジュールが関数とデータをまとめるようにパッケージが複数のモジュールをまとめます。大きなソフトウェアではたくさんのモジュールがあるため管理は困難になります。その際パッケージ化で整理できます。
最初からどのぐらいのモジュールが必要になるか予測できないので最初からパッケージは決められません。よってパッケージボトムアップで設計します。パッケージ化は必要になるときに行います。

## 関心の分離

関心ごとを分離してモジュール化します。コードの変更は関心の単位で行われます。よってある関心に関する情報と機能を局所化すれば修正はバラバラしたコードに変更しないようになります。関心によって影響範囲が限られます。

アスペクト指向プログラミング：横断的関心事のコードを書かないでその機能を自動的に追加します。

## 充足性、完全性、プリミティブ性

充足性：モジュールの目的を表現するような機能を全て持つ

完全性：モジュールに期待される汎用的な機能を全てもつ

プリミティブ性：冗長な機能を持たない

## ポリシーと実装の分離

ポリシー：ソフトウェアの前提条件に依存する。例：ビジネスロジック。
実装：機能を果たすコード。独立で前提に依存しない。

ポリシーは環境によって不安定ですが実装はそうしない。ポリシーがソフトウェアに特化しますが実装は再利用可能です。よって両方を別のモジュールに分離して引数でコミュニケーションをとるべきです。

## インタフェースを実装の分離

インタフェースはクライアントに使われる部分で、適用可能の機能を定義します。実装はその機能をどのように果たすかクライアントに知られるべきではないです。クライアントは簡単にインタフェースを通して必要の結果を取得したいです。よって実装が変わってもクライアントが影響を受けないためインターフェースを分離して安全性を高めます。
インタフェースが求める機能を定義するので実装の設計はインタフェースから考えられます。

## 参照の一点性

副作用を抑えるため変数を一回だけ代入します。変数の値が変えないとコードの流れがとりやすい。そうしない場合は変数に状態によってどの値があるか考えんきゃいけません。

参照透明性：
* 関数の戻り値が引数だけに依存する
* 関数の処理が他の部分に影響しない

関数をこうにすればテスティングが容易、副作用を抑える。

## 分離統治

大きな問題を分割して各部分を解決します。大きな問題は複雑ので小さな部分に集中すれば易しくなります。その方法：

* 独立できる部分を切り分けて解決する
* 責任によってモジュール化
* ボトムアップで解決を考える
* 大量なデータを分割して小さな単位で処理を並行に行う

## アーキテクチャ非機能要件

テスト：非機能のテストはまずそれはどのぐらい必要か定め、テストでその水準を満たすか確認する。

セキュリティ要件：
* 機密性：情報は無許可の第三者に漏れない
* 完全性：情報の安定の保証。無許可第三者に変えられない。
* 可用性：データはいつも可用であり、第三者によって遮断を受けない

# アーキテクチャ非機能要件

## 変更容易性

ソフトウェアは長く生き抜いてるので変更がしやすいべき。「保守性」「拡張性」「再構築」「移植性」を守る。

## 相互運用性

ソフトウェアを他のソフトウェアと連携できる形に設計する。これで既存のソフトウェアを活かせるから効率さが上がり、より大きな問題を解決できる。
相互運用性を果たすため標準規格を雇う。

## 効率性

リソースと時間が限られているので節約に使う。モジュール化による間接化とバランスをとる。

## 信頼性

Fault tolernace: 障害が発生した際も処理を続ける

Robustness:　障害が発生した際エラーを出して処理を停止する

まずシステムの役割によってどのぐらい信頼性が求められるか決める。

果たす方法：

Fault tolerance: 冗長性、大事な処理だけを続けるフェールソフト

Robustness: 障害した所から切り離すフェールセーフ、ユーザーの入力を確認するフェールプルーフ

## テスト容易性

テストは：
効果的：機能を厳しく確認する
効率的：実装と実行が早い

テストコードが本番のコード程重要なので本番のコードに含めても構わない。コードをテストしやすい形に書く。小さなな依存関係が浅い単位で。

## 再利用

再利用の方法：
* 他のソフトウェアからある機能を実装した部分を切り出して自分のソフトウェアに適用化する
* 再利用ためにモジュールを作る

再利用の法則：
* 再利用ための設計は3倍難しい
* 再利用ためのソフトを3の別の場面や文脈にテストしないとどの汎用的な機能が必要か分からない

# ７つの設計原理

## 単純原理

## 同型原理
一貫性を通して同じことを同じように表現する。する障害しそうな場所が違和感的に目立つ。

## 階層原理
階層的な関係について意識しながらコードすると要素の関係を読みやすくとれる。

## 線形原理
線形的にコードを書くとコードが読みやすくなり、もっと早く理解できる。

## 明証原理

一見だけで正しいと分かる明確なコードを書く。コードの読み手が一見だけでロジックを把握できるように。

## 安全原理

いつも安全なコードを書くと大事故の可能性が低くなる。

# UNIX思想

## モジュール化の原理
大きな複雑な問題を解決ためその問題を分割して各機能を責任するモジュールを作り、適当なインタフェースで連携する。

## 明確性の原理
コードの相手はプログラマ同士だから意図が伝わるように明確なわかりやすいコードを書く。

## 組み立て部品の原則
ソフトウェアが他のソフトウェアと組み合わせやすい形にする。相互運用でより大きな問題を解決できる。このためソフトウェアをフィルターのようにする。テキスト入出力するコマンドを作る。

## 分離の原則

## 単純性の原則

## 倹約の原則
大きなコードは複雑なるのでそれを書かない。コードが大きくなると分割する。

## 透明性の原則
* ソフトウェアの動作を一見で分かるように
* 内部の状態を監視できる

そうするとでバッギングが簡単なる。透明性を果たすため動作を見える化する。

## 安定性の原則

ソフトウェアを堅牢にするため：
* 透明：コードが透明だと障害しそうな所が目立つ
* 単純：コードが単純だと流れが把握しやすい

安定性を果たす方法：
* コードレビュー
* 自動的なテストで様々な場合をテスティングする

##  表現性の原則

複雑さをロジックよりデータの方に置く。データの方が理解しやすいから複雑なことをデータの形に表現する。

## 驚き最小限の原則

コードを使いやすくするためできるだけユーザの思い込みを考えていく。コードが予期に動くと深く勉強する必要がない。すぐに既存の知識を活かせる。

## 沈黙の原則

重要な情報だけを出力すると、重要じゃない情報と重要な情報は混ざって出力されない。よってユーザが何が重要か差別する必要がない。全てが重要だと前提できる。

## 修復の原則

動作中ソフトウェアがエラーしたら、回復できないとすぐに激しくエラーを通知して処理を停止する。エラーした状態で処理を続ければエラーの影響範囲が広がり、損害が増える。

## 経済性の原則

プログラマの時間は最も価値なリソースです。よってプログラマが邪魔がないように働けるために投資して、設備や制限などをプログラマのために改善する。

## 生成の原則

コードジェネレーターを作って、基礎的なコードを自動的に生成する。人は簡単な繰り返し手作業が下手なので自動化で効率性と安定性が上がります。

## 最適化の原則

コードを最適化する前に正しい経験を出す、正しい設計を持つと確認しなきゃいけない。正しくないコードの最適化は無駄です。
最適化する際注意点：
* 設計と透明性が犠牲にならない
* ある部分の最適化は全体も最適化する

## 多様性の原則

ソフトウェアで問題の解決には唯一の正しい解法とは存在しない。状況によって解放の上達を続ける。

## 拡張性の原則

ソフトウェアはいつも変更されるためプラグブルな設計で拡張に柔軟する。

# UNIX哲学

## 小なり美なり

小さななソフトウェアは管理しやすい、リソースに軽い。

## 1つ1仕事

各ソフトを一つだけの役割に集中するようにすれば、ソフトの目的と機能と存在理由が明確になる。そうできないと問題をちゃんと把握できなかった。

## 即行プロトタイプ

プロトタイプの開発を通して試行錯誤で問題についてもっと詳しくなる。すると前提などに足りないことを早く把握できる。プロトタイプでユーザとプログラマ全員の思想が合致するか確認できる。

## 効率性より移植性

効率性を上げるとためハードウェアに依存するコードを汎用のコードに混ぜない。ハードウェアに依存する部分をモジュール化して一般物とつなぐ。
ハードウェアに依存するとソフトウェアの価値はハードウェアの価値に依存する。

## データはテキスト

ソフトウェアのデータをテキストの形式で出力する。テキストは特化したバイナリ形式より移植性が高い、他のシステムでも繋げる。人にも単に読める。標準規格はテキストから移植性が上がる。

## Leverage Software

* 既存のソフトウェアを再利用
* 手作業を自動化
* ソフトウェアの唯一な小さな役割を果たすように作る
* グルー言語で各機能の部分をつなぐ

## シェルスクリプト活用

シェルスクリプトをグルー言語として使ってソフトウェアを再利用する。シェルスクリプトは移植性が高くて、グルー言語として専念する。

## 対話インタフェース回避

実行中プログラムがユーザから入力を求めないようにする。対話インターフェースは他のソフトウェアとつながりにくいし、ユーザからの入力を管理する部分が大きいし、入力を待つ必要があるし。

## フィルタ化

プログラムの目的はデータの生成じゃなく、データの加工だからプログラムがデータを入力ストリームとして受け、加工して、出力ストリームとして出力する。

# 第四章：視点

## 凝集度

* 暗合的強度：論理上関係ないけど共通な処理を持つモジュール化。変更理由が共通と保証がないから脆い。
* 論理的強度：論理上関係がある処理。例えば出力に関する関数を集めるモジュール。どの処理が必要か引数で指定する。同じ関数ですべての処理を呼び出すことは脆い。
* 時間的強度：同じときに実行される処理を集めてモジュール化。例えば初期化の処理。
* 手順的強度：ある処理を手順に果たすモジュール。
* 連絡的強度：手順的強度と異なる点はデータを受け渡したり、共通データを参照したりする。
* 情報的強度：一つのデータ構造を管理するモジュール。
* 機能的強度：モジュールの全ての要素が一つの機能を果たすためある。

## 結合度

* 内容結合：他のモジュールのデータを直接に参照する
* 共通結合：グローバル変数を共通に参照する
* 外部結合：他のモジュールの外部宣言変数を参照する
* 制御結合：他のモジュールの関数を呼び出す
* スタンプ結合：データ構造の全体を他のモジュールに渡す
* データ結合：モジュール間データを受け渡す

* べき等性：ある操作を何回行っても結果が変えない
* 安全性：内部の状態を変えない

## 直交性

ソフトウェアをレイヤー化してレイヤーの間の依存性を減らす。

## 可逆性

ソフトウェアは変更しかねないからアーキテクチャと設計に可逆性を置く。

## コードの匂い

直感的に違和感を感じるコードを無視しない。

## 技術的負債

仮に不適なコードを書けばそれをすぐに元あるべき姿に変更する。不適なコードがぞんざいし続くといずれ不適なコードが劇的に増える。

# 第5章：習慣

## プログラマの３大美徳

* 怠惰：手作業を減らすため自動化
* 短期：プログラムが正しく実行するようにこだわる
* 傲慢：誇りと見せるコードを書く

## Boy Scout Rule

不適なコードを見つけたらそれをその時に改良する。

## Performance Tuning の箴言

コードを最適化する前にコードを良い理解しやすい設計にするのに集中する。
performance tuning の手段は bottleneck を見つけ出してそれを改善する。

## Egoless programming

## 一歩ずつ少しずつ

開発際一つのことに集中して少し進歩してその部分をテストしてまた少しコードを書いて、この順番に続ける。この方法は集中しやすい、コードの正しさを確認しながら進歩できる。

## There's more than one way to do it

ツールを作る際、同じ機能を果たすため複数の方法を提供する。それからユーザが状態によって最適な方法を選択でき、良いコードを書ける。これはシンプルとバランスをとる。

# 第6章：手法

## 曳光弾

ソフトウェアの基本的なフレームワークを作って、それに機能追加と修正を改善しながら開発を進歩する。それでいつも本物のソフトを持ってるから機能と設計を確認できる。
プロトタイプと違いはプロトタイプは学習ためのもので必要な情報を得た際捨てられる。一方、曳光弾はいつもフレームワークとして本番のソフトウェアに残る。

## 契約による設計

呼び出す側と呼び出された側の間に両方が満たすべき条件をはっきりする。これは事前条件と事後条件です。前からはっきりして、条件が満たされないとエラーを発生する。エラーの発生にassertionを使う。

## 防御的プログラミング

データをいつもチェックしたらでバッギング性と安全性が高まる。このため処理の間にbarricadeを立ち上げ、移住するデータを確認する。

## Dogfooding

自分が作ってるソフトウェアを自分で使うとユーザーの視点からソフトウェアを評価できる。

## Rubberducking

行き詰まったときプログラムの動作を声で自分に説明すると突然何が問題か把握できる。

## Context

* コードの読み手のコンテクストを考えながらコードを書く
* 問題の解決は問題のコンテクストに依存する

# 第7章

## Brooke's Law

もっと人材を加えて開発期間を短くできない。時間を人で、人を人で交換できない。

## Conway's Law

チームの構造がアーキテクチャの構造に影響する。だから良い設計に辿り着きときチームの構造をアーキテクチャにマッチするようにする。

## 割れた窓の法則

コードに少しでも汚さがあるとそれはもっと汚さを招く。そのためにコードをいつも綺麗にする。

## エントロピーの法則

ソフトウェアはいつも無秩序に向かってるのでいつもその傾向と戦う必要がある。そのため無秩序の目印を見極めてそれを始末する。

## 80-10-10の法則

法則によって8割のユーザーの求めを短時間で実装でき、1割は大時間をかかり、1割は不可能。いつも8割の部分に集中する。特にツールを作るときそれは全てのユーザーの求めを満足できないと意識する。

80-20の法則：結果の8割は役者の2割によって得る。

## Joshua Tree Principle

名前がないものについては考えにくいからuniquitousな名前を付ける。全員がそれについて相談して考えらるように。

## Second System Syndrome

二次システムに余計な機能を付ける癖がある。それに対していつも本当に何が必要か考えて進む。

## 車輪の再発名

いつもソフトウェアを再利用するため同じ必要な機能を果たす既存のソフトウェアがあるとそれ雇う。

## ヤクの毛刈り

ある問題を解決にはまずたくさんの他の問題を解決する必要になる。よっていつも本番の目的を意識する。その基準で副作業をすべきか判断する。
