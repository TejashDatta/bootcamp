# Principles of Programming の概要

# 第1章：前提

## No silver bullet in programming

**どういうこと:** どの場合にも、どのソフトウェアにもある諸問題を鎮める一つの解決策が存在しません。

**どうして:** ソフトウェアその物は本質的に困難性を持っています。その理由：
* **複雑性:** ソフトウェアは大きい
* **同調性:**　ソフトウェアは実世界の状況を表すため、その実世界の状況に影響される
* **可変性:**　ユーザーの要求が変えるため、ソフトウェアも変えなければならない
* **不可視性:** ソフトウェアは概念的な成果物なので、そのものが見えなく、抽象的な可視化しかできない

**どうすれば:** 地道に様々な手法を学んで、複雑さに戦う。

**発展：偶有性の改善:** ソフトウェアの偶有的な部分を改善して本質的な部分の改善できます。

## コードは設計書である

**どういうこと:** コードは製造ではなく、設計書です。

**どうして:** 製造は設計後改善せきません。ですが、コードはよく改善されます。コードは設計書なので改善できます。コードを書かない限り、設計は足りていません。

**どうすれば:** プログラマは設計者である、設計者はプログラマである。コードとして良い設計と立てるべきです。

**関連：Rosetta stone:** ドキュメントとしてコードしか他が価値がないというわけではありません。コードはwhat と howを表現しますが、whyと表現します。ロゼッタストーンのような他のドキュメントは開発環境について説明して、将来の保守者に役に立ちます。

## コードは必ず変更される

**どうして:** ソフトウェアは以下の理由で変更されなくてはなりません：修正、要求の追加、リファクタリング

**どうすれば:** 変更に強いコードは読みやすいコードです。そのため、コードを書くのに時間をかけて、読む時間を短縮します。

# 第二章：原則

# KISS: Keep It Simple, Stupid

**どういうこと:** いつもシンプルなコードを書く。

**どうして:** シンプルなコードは読みやすく、保守性が高いなのです。

**どうすれば:** 意識でシンプルなコードを目指しつつ開発します。例の方法：
* 自分の能力だけをアピールするために複雑なコードを書かない
* 今必要があるコードだけを書いて、将来に必要になるかもしれないコードを書かない
* ユーザーに求めらる要件だけを実装して、勝手に要件あるいは機能を自分の判断だけに基づいて追加しない

**KISSの適用範囲:** コードを書くことだけでなく、機能やインターフェースにも適用する

**関連：Less is more:** 元々余分なコードを書かないと、それによって発生する問題を回避できる

**関連：オッカムの剃刀:** 実装している機能は同じだったら、余分なコードを含めないコードは最も分かりやすいです

## DRY: Don't Repeat Yourself

**どういうこと:** コードをコピーペーストして重複しない。単なるコードを説明するコメントを書かない。

**どうして:** コードは変更しにくくなります。その理由：
* 重複のせいでコードの量が大量になる
* 修正する際、変更の対象節ごとを確認しなきゃいけない
* 重複したコードはレガシーコードであり、テストがないのでいったん力技修正してもいずれまた修正しなきゃ点が出てくる

**どうすれば:** 処理の纏まりとデータに名前を付けて抽象化する。

**発展：DRYの適用範囲:** DRYは全ての繰り返し作業に適用します。例えばビルド、リリース等の作業を自動化すること。

**発展：DRYとプログラミング技術:** プログラミングの技術とデザインパターンのような設計手法はDRYを実現する目的とします。

**発展：全ての場合にDRY を適用できない:** Impedance mismatch: データの抽象スタイルが異なると、同じデータの表現も異なるので再度表現表現があります。

**関連：WET:** WET: Write Everything Twice. DRYの対義語。

**関連：OFOP: One Fact in One Place:** OFOPはデータベースの設計における。不正後を避ける。正規化で実現される。

**関連：OAOO: Once And Only Once:** DRYより適用範囲は狭く、プログラミングの文脈だけにおける。

**関連：レガシーコード:** 重複したコードは多くの場合、テストがないコードです。レガシーコードはテストがないから改善しても良くなったか悪くなったか分からない。

## YAGNI: You Aren't Going To Need It

**どういうこと:** 必要最低限のコードだけを書く。

**どうして:** 必要になるコードの予測は不可能です。ほとんどの場合は予想が外れるので利用になりません。無用なコードは主に二つの損を生みます：
1. 無用な拡張の開発にかけた時間は無駄になります
2. コード全体の保守がしにくくなります

**どうすれば:** 汎用性である複雑な設計より単純な設計を追求します。機能の拡張性に対しても単純性がベターです。なぜなら単純なコードは変更しやすいです。

**発展：YAGNIの適用範囲：**　ソフトの機能に関しても、余計な機能を実施しない。なぜならソフトウェア全体の使用を複雑にする。

**関連：Do The Simplest Thing That Could Possibly Work:** YAGNIと同じように、現時点で必要があるコードだけを書くことにする。

## PIE: Program Intently and Expressively

**どういうこと:** コードの読み手はマシンより人だから、コードを読めばソフトウェアがどう動いてるか明確に理解できるようなコードを書く。

**どうして:** どのドキュメントよりも、コードはソフトウェアの動作の詳細を記述するのでソフトウェアを深く理解したい人はコードを読まなきゃいけない。なのでコードが意図を伝えることは重要です。

**どうすれば:** 書く効率や実行効率より読む効率を最優先にする。コードは一回書かれるけど何度も自分だけでなく他人にも読まれる。なので書くことに時間をかけて読むことを容易にすれば非線形な価値がある。

**発展：モグラたたきを避ける：**　最初から品質の良い、テストがあるコードを書かないといと障害が連続に出てくる。どの時どこに障害が発生するがわからないようになる。なのでプロジェクトの期間はきつくあってもコードの品質は犠牲にならないべき。

**発展：コメント：**　コードはwhatとhowを伝えるのでコメントはwhyを伝えるべきです。

## SLAP: Single Level of Abstraction

**どういうこと:** 関数を抽象レベルによって階層化します。

**どうして:** 関数の呼出が要約のようになります。処理の塊が小さいので閲覧性が上がります。

**どうすれば:** 一段低いレベルの関数を呼ぶ複合関数を活かします。

**発展：SLAPの適用範囲：**　関数のようにモジュール間も継承を活かして抽象によって階層化できます。

**発展：SLAPの手順：**　まず機能の具体的な実装して、そのあと抽象化レベルを揃えます。

## OCP: Open Close Principle

**どういうこと:** 
* Open: 変更に対して開いています.
* Close: コードを変更しても、他のコードに影響しません。

**どうして:** 変更に対して柔軟性をもたらします。

**どうすれば:** コードにインタフェースを用います

**発展：OCPの適用範囲：**　柔軟性を言い訳にして、複雑な設計をすべきではないです。ソフトウェアの変更は予測できないのでシンプルな設計は最も柔軟的です。確実に変更しそうな部分を流動的要素のカプセル化します。

**発展：OCP の実装と設計：**　多態性、いくつかのデザインパターン、compile time linking

**関連：バリエーション防護壁：** 種類（バリエーション）が予測されるなど、不安定箇所との接点を識別し、接点の周辺に安定したインタフェースが築かれるように責任を割り当てる、というものです。

## 名前重要
**どういうこと:** 
* 名前を付けること:　適切な名前を付けられたということは、その要素が正しく理解されて、正しく設計されているということです。
* 名前そのもの:　名前は、コードを通じて、プログラマ同士がコミュニケーションするための最大の場となります。

**どうして:** 名前はコードを読む人への「UI」です。読むときに意図を伝えり、書くとき名前にみちびかされします。

**どうすれば:** 
名前は：
* 短いコメント
* 誤解されないように
* 「効果」と「目的」を説明します。「手段」には言及しません。
* コードを書く前にテストを用意します
* 発音可能
* 検索可能

**発展：メンタルマッピング回避**　不適な名前であればコードを詳しく読んで、処理を理解して、自分で名前を付ける必要があります。

**関連： loop back check：** 説明→名前→説明の順で、1周回って元に戻る（ループバックする）ように説明が一致すればよい名前で、一致しなければ要注意となります。

# Programming Theory
# プログラミングセオリーを支える価値
## Communication

**どういうこと:** コードも、人に見せる「文書（ドキュメント）」です。

**どうして:** コードを通して、プログラマ同士が円滑にコミュニケーションするためです。

**どうすれば:** コードを読む側の視点に転回します。

<まとめる途中>

## 階層原理

**どういうこと:** 同じ種類の処理を同じ階層で行います。例えば、リソースを取得すれば、解放も同じ階層で行います。

**どうして:** 抽象が理解しやすいのでコードが読みやすくなります。

**どうすれば:** 抽象のレベルによって階層を構築します。上位から下位を見ると外部から見ているようにします。

## 線形原理

**どういうこと:** ある機能をいくつかの機能の線形的に（条件分岐なし）重ね合いによって立てます。

**どうして:** 処理の流れが読みやすくなります。上から下の順番に読めるコードはわかりやすいです。

**どうすれば:**　条件分岐を避けること。そのため、特殊な振る舞いを主処理に混ぜません。

## 明証原理

**どういうこと:** 一見で正しいと分かるコードを書きます。

**どうして:** コードの不確実性は取り除きます。

**どうすれば:** 明確なコードを書きます。

**発展：再利用のリスク：** コードの動作仕様と文脈を理解してから再利用すべきです。ある場面に使用実績があったから他の場面でも実績を残すというさけではありません。

**発展：コードの障害修正のリスク：**　コードと障害理由を完全に理解して修正に取り組むべきです。障害に敵する多くのテストを提供します。

## 安定原理

**どういうこと:**　必然性のないところや曖昧なところは、安全サイドで設計・プログラミングしておくことです。
ありえないと思いつつ状態に対して用意します。例えばif文でありえないと思うelse文を書いておきます。

**どうして:** 事故の可能性が低くても、安全ための措置をおくべきです。

**どうすれば:**　ありえないと思う条件に対しても用意します。

**発展：再利用のリスク：** コードの動作仕様と文脈を理解してから再利用すべきです。ある場面に使用実績があったから他の場面でも実績を残すというさけではありません。

**発展：コードの障害修正のリスク：**　コードと障害理由を完全に理解して修正に取り組むべきです。障害に敵する多くのテストを提供します。

# UNIX 思想

## モジュール化の原理

**どういうこと:**　シンプルなインターフェースを持つモジュールを作ります。モジュールの要素の間の関係性が高いです。

**どうして:**　ソフトウェアの複雑さを抑えます。

**どうすれば:**　モジュールは余計な機能を提供しません。インターフェースはシンプルになります。

## 組み立て部品の原理

**どういうこと:** ソフトウェアをフィルターとして作ります。入力をでデータストリームとして受け、加入して、別のデータストリームとして出力します。

**どうして:** 他のソフトウェアと組み合わせができればたくさんの複雑な問題を楽に解決できます。

**どうすれば:**　テキストストリームとして出力すればソフトウェアの汎用性が上がります。連絡が簡単になります。

## 分離の原則

ポリシー：ソフトウェアの前提に依存する不安定な部分です。
メカニズム：前提に依存しない、独立して安定な部分です。

**どういうこと:** ポリシーとメカニズムを分離します。

**どうして:**　ポリシーとメカニズムが混在であれば２つの欠点：
1. ポリシーの変更は難しくなります
2. ポリシーが変更はメカニズムに影響を与えます

ポリシーとメカニズムを分離するメリット：
* メカ二ズムを壊さずにヽ 新しいポリシ一を試せるようになります。
* メ力二ズムが独立しているのでヽ メカ二ズムの有効なテス 卜を害きやすくなります。メカ二ズムの寿命は長いのでヽ 投資対効果の高いテス 卜になり ます 。
* メカ二ズムが独立していればヽ 他のソフ 卜ウエアで再利用も可能です。

**どうすれば:**　安定的な部分と不安定な部分を明確に分けて管理します。

## 単純性	の原則

**どういうこと:** いつもシンプルさを追求します。

**どうして:**　コードは自然的に複雑なります。その原因：
1. プログラマが技術力を誇示したいです
2. 余計な機能を追加すればソフトウェアの価値が上がるという間違った考え方

**どうすれば:**　上記の傾向を拒否します。

## 倹約の原則

**どういうこと:** 大量な、複雑なコードを書きません。

**どうして:**　コードの管理は難しくなります。

**どうすれば:**　小さなコードを書きます。大きなコードを分割します。

## 透明性の原則

**どういうこと:** 
透明的：ソフトウェアの動作について、一目見てすぐに「何をどのようにしているのか」が理解できること。
開示的：ソフトウェアの内部状態について、監視ないし表示できること。

**どうして:** デバッグに貢献します。

**どうすれば:**　	デバッグのための機能を、設計の最初の段階から組み込みます。デバッグを簡単にする仕組みを、本番コードに組み込むことを躊躇してはいけません。

## 安定性の原則

**どういうこと:** 予想外の条件を考慮したコードを書きます。そのため満たすべきこと：
透明性：コードを見通すことができて、何が起きているのかがすぐにわかるようなコード
単純性：コードで行われていることが複雑でなく、すべての分岐条件を難なく説明できるようなコード

**どうして:** ソフトウェアは安定でなければユーザーが使いたくなくなります。

**どうすれば:**　	コードを透明と単純にするため：
* コードレビュー
* 幅広いテストケースに対してテスティングします。

## 表現性の原則

**どういうこと:** コードにおける情報の表現方法は、ロジックでなくデータに寄せて書くようにします。

**どうして:** ロジックよりデータの方が分かりやすいです。

**どうすれば:** 複雑さをデータに寄せる

## 驚き最小限の原則

**どういうこと:** ユーザーの予想通りのインタフェースを作ります。

**どうして:** インタフェースを予想通りに使えればソフトウェアを学習する必要が低くなります。既存の知識を活用できますし。

**どうすれば:** 
* よく似たソフトウェアのインタフェースをモデルにする
* 想定ユーザーの特徴を考慮する
* 伝統に注意を払う
* 「一見似ているが微妙に異なる」ということを避ける

## 沈黙の原則

**どういうこと:** どうしても言わなければならない想定外なことがないのなら、ソフトウェアは「何も言わない」ようにします。ソフトウェアは寡黙にします。

**どうして:** 出力が多いと、ユーザーは、自分にとって大切な情報がどれかわかりません。すべての出力が大切だと出力から大切な部分を仕分けする必要がなくなります。

ソフトウェア同士とも接続はしやすくなります。

**どうすれば:** 
* 本当のエラーだけを標準エラー出力に表示
* デバッグの目的で冗長モードのスイッチを作り、それをデフォルトに無効にします。

## 修復の原則

**どういうこと:** ソフトウェアの動作中、エラーの回復に失敗したのであれば、処理は継続すべきではありません。そのエラーを目立つようにします。

**どうして:** 障害発生の時、回復できないまま処理を続けると障害の範囲が広がります。

**どうすれば:** 障害を回復できないときにけたたましくエラー通知します。

**発展:** ソフトウェアの入力と出力に関して、『受け入れるものについては「自由主義（リベラル）」に、送るものについては「保守主義」に』という考え方があります。

## 経済性の原則

**どういうこと:** プログラマの時間が高価なリソースなので節約します。それを浪費するのは：
* ハードウェアが貧弱
* 使用するソフトウェアに対する制限
* 環境に関するルールや制限

**どうして:** プログラマの時間が設備より高価なリソースです。

**どうすれば:** プログラマに投資します。

**発展:** ソフトウェアの入力と出力に関して、『受け入れるものについては「自由主義（リベラル）」に、送るものについては「保守主義」に』という考え方があります。

## 生成の原則

**どういうこと:** コードを書くコードを書きます。

**どうして:** コードに対する手動の単純作業は人が長手でミスや遅れを起こしてしまいます。

**どうすれば:** コードジェネレーターを作ります。

## 最適化の原則

**どういうこと:** プログラムを最適化する前にプログラムが正しいか保証します。

**どうして:** 正しくないコードを最適化すればその努力が無駄になります。以下の問題が起こります：
* 透明性や単純性が犠牲になる
* 部分に対する半端な最適化が、全体の最適化の妨げになる

**どうすれば:** コードを正しくしてから速くします。

**発展:** プロトタイプを使うと、「コードを書かなくて済む機能がわかる」という学習効果があります。

## 多様性の原則

**どういうこと:** 唯一の正しい方法が存在しません。

**どうして:** 人の想像に限りがあるので、すべての場面に対して最適な機能たっぷりなソフトウェアを開発できません。

**どうすれば:** よりよいやり方を求め続けます。

## 拡張性の原則

**どういうこと:** 拡張できる設計にしておきます。

**どうして:** ソフトウェアは変更しかねません。

**どうすれば:** プラガブルな設計にします。

**発展:** データ形式にバージョン番号を付けます。

# UNIX哲学

## 小は美なり

**どういうこと:**小さいソフトウェアは、シンプルで、扱いやすく、大きいソフトウェアよりもはるかに優れています。

**どうして:** 小さいソフトウェアは扱いやすい。
* 理解が容易
* 保守が容易
* マシンリ ソ一スに負担をかけない
* 他のソフ トウエアと組み合わせゃすい
* 複雑で、コードの理解が困難
* 不測の事態に対応できない

**どうすれば:** 小さく作って小さく保ちます。問題を完全に理解していないがために、巨大な解決策を考え、巨大なソフトウェアになってしまうのです。

## 1つ1仕事

**どういうこと:** 1つのソフトウェアは1つの仕事

**どうして:** 大きなソフトウェアは：遅い、問題をちゃんと把握できなかったという証拠、再利用性が低いです。

**どうすれば:** 大きな問題を分割、新機能の追加の誘惑に負けない。

## 即行プロトタイプ

**どういうこと:** できるだけ早くプロトタイプを作ります。

**どうして:** 試行錯誤を通して問題に対してもっと詳しくなります。全員の意見は一致します。

**どうすれば:** 
* 前提の誤 り を早期に発見でき る
* 要件不備によ る手戻り を減ら せる
* 早いう ちから誤り を取り除く 作業を始められる

**関連:　第3システム：**　３つのシステムの開発を通していいシステムに辿り着きます。
第一システム：機能が足りない
第二システム：余計な機能がある
第三システム：バランスが良い
 
## 効率性より移植性

**どうして:** ソフトウェアがハードウェアに依存すれば、ソフトウェアの価値と持続がそのハードウェアに依存します。

**どうすれば:** ハードウェアに依存する部分を切り離します。

## データはテキスト

**どういうこと:**データはテキストファイルに保存します。

**どうして:** 
* 移植性が高い
* 人に読みやすい
* 変換の必要がない

**どうすれば:** ソフトウェアの入出力をテキストファイルの形にします。

## Leverage Software

**どういうこと:** 既存のソフトウェアと組み合わせにして問題を解決します。

**どうして:** 既存のソフトウェアを活かせば自分の手作業が減少します。

**どうすれば:**
1. 既存のソフトウェアと組み合わせます
2. 自動化

## シェルスクリプト活用

**どういうこととどうして:** シェルスクリプトによって、梃子の効果と移植性を高めます。

**どうすれば:**　シェルスクリプトをグルー言語として使います。

## 対話インタフェース回避

**どういうこと:** 拘束的ユーザーインタフェースは避けます。

**どうして:** 
* ソフトウェアごとの独自の対話方法を覚えなければならない
* ソフトウェア同士が対話できなくなる
* 待ち時間が多くなる
* 入力部分の解析コードが大きく、醜くなる
* 「大は美なり」的なアプローチになる

**どうすれば:** あくまで、ソフトウェアの会話の相手は、人間ではなく、ソフトウェアを中心に考えるようにします。
